package com.pander.paixu.数据库;

/**
 * @author: sunxuefei10
 * @date: 2021/5/3  4:29 下午
 */
public class 数据库锁 {
    /**
     * 数据库锁的粒度分为行锁和表锁
     *
     * 行锁：可以使用索引的行
     * select * from user where id = 3 for update;
     *
     * 表锁：搜索字段没有使用索引
     * select * from user where name ='kk' fro update;
     *
     * 表锁算法：（锁机制），mysql自己决定使用哪种锁
     *
     * Record Lock 普通行锁
     * 键值在条件范围内
     * 记录存在
     *
     *
     * Gap Lock 间隙锁
     * 对于键值不存在条件范围内，引擎就会对这个间隙加锁，这种机制就是Gap机制，锁上不锁下
     * a:是主键 b:是普通索引
     * 比如说对一个普通索引进行修改，执行b=5 for update ，5这条数据不存在，那么它就会所锁住5数据上下的值之间的所有操作，就是X,GAP
     * 如果对一个普通索引进行修改，执行b=3 for update ,3这条数据存在，那么就会把3这条数据的上面一个值之间和下面一个值之间都会锁住，X、GAP锁
     * 如果对一个主键进行修改,执行a=3，那么这时候的Next-Key锁回退化成Record—Lock锁
     *
     *
     * Next-Key Lock 行&间隙锁
     * 在键值范围内，同时键值又不存在条件范围内
     *
     *
     *
     * 表锁算法
     *
     * 意向锁：当一个事务带着表锁去访问一个被加了行锁的资源，那么此时，这个行锁就会升级成意向锁，将表锁住。
     *
     * 自增锁：事务插入自增类型的列时，获取自增锁。
     *
     *
     * 实现：共享锁、排它锁
     *
     * 行锁和表锁是锁粒度的概念，共享锁和排它锁是他们的具体实现。
     *
     * 共享锁（S）：允许一个事务去读一行，阻止其他事务去获取该行的排它锁。lock in share mode
     *
     *
     * 排它锁（X）：允许持有排它锁的事务读写数据，阻止其他事物获取该资源的共享锁和排它锁。select for update。insert、update
     *
     * 乐观锁：一般通过版本号进行更新操作，CAS简化版本
     *
     * 悲观锁：相当于排它锁
     *
     *
     * 当在一个事务中添加锁比如for update锁定一条数据，但是其他普通读可以直接进行读操作，是不影响普通读的。
     *
     *
     * 锁和索引的关系：使用独占锁来操作sql语句来操作不是索引的数据，那么会锁表。
     *锁除了在耳机索引上加锁，还会在聚簇索引上加锁
     *
     *
     *死锁成因：
     * 当两个事务操作不同表相同行数据时，会产生死锁，
     *
     * 当两个事务操作一张表的不同数据也会产生死锁
     *
     * gap锁冲突，就是不同事务操作一张表的gap锁，另一个事务又要操作这个事务持有的gap锁，这个事务又要操作另一个事务的gap锁的记录，就产生
     * 了死锁。
     */
}
