进程：是资源分配的基本单位
线程：程序运行的基本单位

上下文切换：主要是cpu的指令寄存器将a线程的数据拷贝到缓存中，将b线程的数据拷贝到指令寄存器中

cpu有缓存的概念：多核cpu的每个核单独享有L1、L2缓存，一颗cpu的多个核共享cpu的L3缓存。

系统总线：
内存总线：
IO总线：

cpu如果修改的是一个缓存行的数据那么直接通过mesi的协议来保证，一个cpu修改，其他cpu的数据失效。但是如果修改的是多个缓存行的数据，那么就需要总线锁。
就是操作系统的lock指令。




java的线程模型：对应的是操作系统的线程是1：1对应的，所以对于线程的资源的争抢都依赖于操作系统去实现。同时jvm在操作系统层面也是一个特殊的进程。
针对于golang的协程，其实是n：m，比较类似于线程池，m是操作系统启动的线程数，而对应的是几个队列里面的任务，golang会把这n个协程封装成任务，
然后操作系统的线程去拿任务

synchronized：重量级锁，要经过操作系统底层，

轻量级锁：乐观锁来实现，cas，自旋锁。
cas是如何实现原子性的，因为cas需要先比较再替换，如果这之中不是原子性的，那么就会在比较的时候其他线程去进行了修改。

lock cmpxchg指令：在硬件层面上会在执行后面指令的时候锁定一个北桥信号，不采用锁总线的方式。

偏向锁：首先将自己的锁id写到对象头，现在没有资源竞争的概念。
轻量级锁：
重量级锁：

mark word 对象头(锁信息和垃圾回收信息)
object class loader 类指针(也是对象头的数据，只是指向的是类的地址)

instance data 实例数据
padding 字节对齐

偏向锁是不是一定会效率提升，多线程竞争的情况下会导致效率下降。

synchronized内部实现机制主要依赖monitor机制，里面有entryList、waitSet，这之中主要的作用是entryList保存的是block的线程，而waitSet保存的是
wait等待的线程，里面有一个owner字段。
